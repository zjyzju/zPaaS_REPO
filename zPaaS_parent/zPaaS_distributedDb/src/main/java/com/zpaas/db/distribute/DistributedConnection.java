package com.zpaas.db.distribute;

import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.zpaas.db.base.ConnectionBase;
import com.zpaas.db.common.ConnectionManager;
import com.zpaas.db.common.DistributedTransactionManager;

/**
 * 分布式数据库的Connection类
 * @author zjy
 * @date 2014年6月23日 上午9:54:18 
 * @version V1.0
 */
public class DistributedConnection extends ConnectionBase {
	public static final Logger log = LoggerFactory.getLogger(DistributedConnection.class);
	private DistributedDBRule dbRule = null;
	protected ConnectionManager manager = null;
	
	public DistributedConnection() {
		manager = new ConnectionManager();
	}
	
	@Override
	public Statement createStatement() throws SQLException {
		if(this.isClosed()) {
			return null;
		}
		DistributedStatement e = new DistributedStatement();
		e.setManager(manager);
		e.setDbRule(dbRule);
		e.setConnection(this);
		return e;
	}

	@Override
	public PreparedStatement prepareStatement(String sql) throws SQLException {
		if(this.isClosed()) {
			return null;
		}
		DistributedPreparedStatement ps = new DistributedPreparedStatement(sql);
		ps.setManager(manager);
		ps.setDbRule(dbRule);
		ps.setConnection(this);
		return ps;
	}
	
	@Override
	public Statement createStatement(int resultSetType, int resultSetConcurrency)
			throws SQLException {
		if(this.isClosed()) {
			return null;
		}
		DistributedStatement e = (DistributedStatement)createStatement();
		e.setResultSetType(resultSetType);
		e.setResultSetConcurrency(resultSetConcurrency);
		return e;
	}

	@Override
	public PreparedStatement prepareStatement(String sql, int resultSetType,
			int resultSetConcurrency) throws SQLException {
		if(this.isClosed()) {
			return null;
		}
		DistributedPreparedStatement ps = (DistributedPreparedStatement)prepareStatement(sql);
		ps.setResultSetType(resultSetType);
		ps.setResultSetConcurrency(resultSetConcurrency);
		return ps;
	}

	@Override
	public Statement createStatement(int resultSetType,
			int resultSetConcurrency, int resultSetHoldability)
			throws SQLException {
		if(this.isClosed()) {
			return null;
		}
		DistributedStatement e = (DistributedStatement)createStatement();
		e.setResultSetType(resultSetType);
		e.setResultSetConcurrency(resultSetConcurrency);
		e.setResultSetHoldability(resultSetHoldability);
		return e;
	}

	@Override
	public PreparedStatement prepareStatement(String sql, int resultSetType,
			int resultSetConcurrency, int resultSetHoldability)
			throws SQLException {
		if(this.isClosed()) {
			return null;
		}
		DistributedPreparedStatement ps = (DistributedPreparedStatement)prepareStatement(sql);
		ps.setResultSetType(resultSetType);
		ps.setResultSetConcurrency(resultSetConcurrency);
		ps.setResultSetHoldability(resultSetHoldability);
		return ps;
	}

	@Override
	public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys)
			throws SQLException {
		if(this.isClosed()) {
			return null;
		}
		DistributedPreparedStatement ps = (DistributedPreparedStatement)prepareStatement(sql);
		ps.setAutoGeneratedKeys(autoGeneratedKeys);
		return ps;
	}

	@Override
	public PreparedStatement prepareStatement(String sql, int[] columnIndexes)
			throws SQLException {
		if(this.isClosed()) {
			return null;
		}
		DistributedPreparedStatement ps = (DistributedPreparedStatement)prepareStatement(sql);
		ps.setColumnIndexes(columnIndexes);
		return ps;
	}

	@Override
	public PreparedStatement prepareStatement(String sql, String[] columnNames)
			throws SQLException {
		if(this.isClosed()) {
			return null;
		}
		DistributedPreparedStatement ps = (DistributedPreparedStatement)prepareStatement(sql);
		ps.setColumnNames(columnNames);
		return ps;
	}

	@Override
	public void close() throws SQLException {
		if(DistributedTransactionManager.isInTransaction()) {
			if(log.isDebugEnabled()) {
				log.debug("{} is in transaction, abandon closing.", this);
			}
			return;
		}
		if(log.isDebugEnabled()) {
			log.debug("{} is closed.", this);
		}
		if(manager.getStatementList() != null && manager.getStatementList().size() > 0) {
			for(Statement e : manager.getStatementList()) {
				try {
					e.close();
				} catch (Exception e1) {
					log.error(e1.getMessage(),e1);
				}
			}
			manager.setStateList(new ArrayList<Statement>());
		}
		if(manager.getConnMap() != null && manager.getConnMap().size() > 0) {
			for(String dbName : manager.getConnMap().keySet()) {
				try {
					manager.getConnMap().get(dbName).close();
				} catch (Exception e) {
					log.error(e.getMessage(),e);
				}
				if(DistributedTransactionManager.isInTransaction()) {
					DistributedTransactionManager.unbindConnection(dbName);
				}
			}
		}
		closed = true;
	}

	@Override
	public void commit() throws SQLException {
		if(this.getAutoCommit()) {
			return;
		}
		if(log.isDebugEnabled()) {
			log.debug("{} is commited.", this);
		}
		if(manager.getConnMap() != null && manager.getConnMap().size() > 0) {
			for(String dbName : manager.getConnMap().keySet()) {
				try {
					manager.getConnMap().get(dbName).commit();
				} catch (Exception e) {
					log.error(e.getMessage(),e);
				}
				if(DistributedTransactionManager.isInTransaction()) {
					DistributedTransactionManager.unbindConnection(dbName);
				}
			}
		}
	}

	@Override
	public void rollback() throws SQLException {
		if(this.getAutoCommit()) {
			return;
		}
		if(log.isDebugEnabled()) {
			log.debug("{} is rollbacked.", this);
		}
		if(manager.getConnMap() != null && manager.getConnMap().size() > 0) {
			for(String dbName : manager.getConnMap().keySet()) {
				try {
					manager.getConnMap().get(dbName).rollback();
				} catch (Exception e) {
					log.error(e.getMessage(),e);
				}
				if(DistributedTransactionManager.isInTransaction()) {
					DistributedTransactionManager.unbindConnection(dbName);
				}
			}
		}
	}

	public DistributedDBRule getDbRule() {
		return dbRule;
	}

	public void setDbRule(DistributedDBRule dbRule) {
		this.dbRule = dbRule;
	}
}
